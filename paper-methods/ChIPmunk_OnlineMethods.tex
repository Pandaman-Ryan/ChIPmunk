\documentclass[12pt]{article}

% Imports
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}
\usepackage{ctable}
\usepackage{array}
\usepackage{titlesec}

% Paragraph spacing
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

% Default font
\renewcommand*{\familydefault}{\sfdefault}

% title spacing
\titlespacing*{\section}
{0pt}{2pt}{0pt}
\titlespacing*{\subsection}
{0pt}{2pt}{0pt}

% table lines
\newcolumntype{?}{!{\vrule width 1pt}}

% hyperlinks
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=red,
  citecolor=red,
 }

\begin{document}

\section*{Online Methods}

\subsection*{ChIPmunk model}

ChIPmunk models the shearing, pulldown, PCR, and sequencing steps of ChIP-seq and learns the parameters for each of these steps described in Table 1. 

\subsubsection*{Shearing}

Paired end

Paired end sequencing is the process of generating reads by sequencing both ends of the sequence fragment and thus allowing us to know the length of these fragments. Using this concept, we can take paired end ChIP sequencing data and read in fragment lengths at random points in the genome in order to find the gamma distribution that best models these lengths. In particular, the learn module reads in 10000 randomly selected fragment lengths from the inputted paired end bam file. These are filtered to remove error fragments that exceed the length $3 * \text{median}$. Using the fragment lengths can generate their mean, $\mu = \dfrac{\Sum_{i=1}^{n}X_i}{n}$. Now, using the method of moments: 
$$k\theta = \mu$$
$$k{\theta}^2 = \dfrac{1}{n}\Sum_{i=1}^n(X_i - \mu)^2$$  
Using these we can solve for $k$ and $\theta$ as $k = \dfrac{\mu}{\theta}$ and $\theta = \dfrac{1}{n\mu}\Sum_{i=1}^{n}(X_i - \mu)^2$
We can recreate the gamma distribution based off of these parameters learned and generate random fragment lengths that closely follow this distribution to use in simulator.

Questions: How did we figure out the fragements distribution aligns closest with the gamma dist?

Single end


\subsubsection*{Pulldown}

**Go into math behind how we setup pulldown**

The pulldown step of the simulator represents purifying the precipitated DNA by washing away the sheared fragments that were not bound by the target protein or histone modification. These filtered fragments are then marked to be sequenced. The filtering process is not perfect and therefore some fragments not bound will also be pulled down to be sequenced which we label as noise. In order to model this process we start at a given position in the genome based on the region specified by the user. The random fragment is generated and based on its location we can generate its peak score. The peak score is a metric based on the peak intensity read from the bed file that the user inputted. The higher the intensity the higher the probability that a fragment will be mapped to that location. This isn't the only factor to determine if the fragment will be bound. Let $P_b$ be the probability of being bound. 
$P_b = \text{peak score} * P_{kept}$ where $P_{kept} = \dfrac{numreads * pcr_rate}{numfrags_per_run * numcopies}$

\subsubsection*{PCR}

\subsubsection*{Sequencing}

After all the fragments have been pulled down, it is time to generate the fastq reads through the sequencing process. At the start of this process we go through each fragment that was successfully pulled down and use its chromsome, start, and end positions to grab the sequence from the reference genome. If the sequencing method is paired end we take the first $n$ nucleotides, where $n$ is decided by the user input parameter readlen, and write out this read to the first fastq file. Then we take the reverse complement of the last $n$ nucleotides and output this to the second fastq file matching the index of the first. (Make sure to include read quality score)Otherwise if single end was specified, only the first $n$ nucleotides are outputted to a single a fastq. 

Do I need to specify the full output to the fastq files?

\subsection*{ChIPmunk implementation}

two modules
file formats
binning
C++, any special libraries we use, open source

\subsection*{Peak caller evaluation}

\subsection*{Data sources}


\end{document}
